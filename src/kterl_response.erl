%% Copyright (c) 2012, Rich Beerman <rbeer@beerman.org>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

%% @private

-module(kterl_response).

-include("kterl.hrl").
-include("ktinternal.hrl").
-include("ktbin.hrl").

-export([init/0,parse/2]).

-spec init() -> parser_state().

init() -> undefined.

%% @doc read a buffer generated by ktserver, and attempt to assemble a
%% completed response to return to the caller.
%%
%% This function handles both http and binary protocol responses. HTTP
%% responses are buffered into a single (potentially large) binary until
%% 'Content-Length' bytes have been received. Since this function is
%% invoked by the kterl_client gen_server, the http body is not
%% deserialized until it's returned to the caller. This will likely
%% increase throughput in cases where there are multiple callers
%% utilizing a single gen_server connection handler. Also, overhead
%% associated with copying an HTTP call response to the caller's
%% process will likely be mitigated.
%%
%% Binary responses such as get_bulk and play_script are deserialized
%% from their binary representations and gathered into a (potentially
%% large) list of #kt_bin_rec{} records. This list is eventually passed to
%% the caller's process when the entire response has been received.
%% Protocol deserialization occurs here because it's fast, and also because
%% the software doesn't have an exact length of a binary response without 
%% first examining the key and value lengths of each record contained 
%% in the response.
%% 
%% When the parse function requires additional data to successfully
%% interpret a response, it'll return {continue, State, Rest}, with
%% Rest containing an incomplete binary buffer. Additional data from
%% the server will be appended to this buffer, and parse() will once
%% again be called.

-spec parse(parser_state(), Data::binary()) -> 
    {'continue', parser_state()} 
  | {'continue', parser_state(), binary()}
  | {#http_response{} | #binary_response{}, parser_state(), binary()}.


parse(undefined, Data) ->
    case Data of
        <<>> ->
            {continue, init()};
        <<?BIN_MAGIC_SET_BULK:8, Nrecs:32/big-unsigned-integer, Rest/binary>> ->
            {gen_response(#binary_state{type = set_bulk, tot_recs = Nrecs}), 
             init(), Rest};
        <<?BIN_MAGIC_REMOVE_BULK:8, Nrecs:32/big-unsigned-integer, Rest/binary>> ->
            {gen_response(#binary_state{type = remove_bulk, tot_recs = Nrecs}), 
             init(), Rest};
        <<?BIN_MAGIC_PLAY_SCRIPT:8, Nrecs:32/big-unsigned-integer, Rest/binary>> ->
            parse(#binary_state{type = play_script, tot_recs = Nrecs}, Rest);
        <<?BIN_MAGIC_GET_BULK:8, Nrecs:32/big-unsigned-integer, Rest/binary>> ->
            parse(#binary_state{type = get_bulk, tot_recs = Nrecs}, Rest);
        <<IBR:8, _/binary>> when (IBR band ?BIN_MASK) == ?BIN_MASK ->
            {continue, undefined, Data};        %binary protocol needs more data
        _ ->
            parse(#http_state{state = http_response}, Data)
    end;

parse(#http_state{state = http_response} = State, Data) ->
    case erlang:decode_packet(http, Data, []) of
        {ok, {http_response, _, Code, _}, Rest} ->
            parse(State#http_state{state=http_header, status_code=Code}, Rest);
        {more, _Length} ->
            {continue, State, Data}
    end;

parse(#http_state{state = http_header} = State, Data) ->
    case erlang:decode_packet(httph, Data, []) of
        {ok, http_eoh, Rest} ->
            parse(State#http_state{state = http_body}, Rest);
        {ok, {http_header,_,'Content-Type',_,CT}, Rest} ->
            parse(State#http_state{response_enc = get_colenc(CT)}, Rest);
        {ok, {http_header,_,'Content-Length',_,Rlen}, Rest} ->
            CL = list_to_integer(Rlen),
            parse(State#http_state{content_length = CL}, Rest);
        {ok, _, Rest} ->
            parse(State, Rest);
        {more, _Length} ->
            {continue, State, Data}
    end;

parse(
  #http_state{state = http_body, content_length = undefined}, _Data) ->
    erlang:error("Didn't receive Content-Length in response.");
parse(
  #http_state{state = http_body, content_length = CL} = State, Data) ->
    case byte_size(Data) >= CL of
        true ->
            <<Resbody:CL/bytes, Rest/bytes>> = Data,
            {gen_response(State#http_state{body = Resbody}), init(), Rest};
        false ->
            {continue, State, Data}
    end;

parse(#binary_state{type = T, tot_recs = TR, n_recvd = NR} = State, Data) 
  when (T =:= play_script orelse T =:= get_bulk) andalso NR =:= TR ->
    {gen_response(State), init(), Data};
parse(#binary_state{type = T, n_recvd = NR, recs = Recs} = State, 
      Data) when T =:= play_script; T =:= get_bulk ->
    case read_binrec(T, Data) of
        {BR, Rest} ->
            parse(State#binary_state{recs = [BR | Recs], n_recvd = NR+1}, Rest);
        undefined ->
            {continue, State, Data}
    end;
parse(State, Data) ->
    erlang:error("Unknown parse state! State=~p Data=~p",[State, Data]).


-spec read_binrec(
        'play_script' | 'get_bulk', binary()) ->
    {#kt_bin_rec{}, binary()} | undefined.

read_binrec(
  play_script, <<Ksiz:32/big-unsigned-integer, Vsiz:32/big-unsigned-integer,
                Key:Ksiz/bytes, Val:Vsiz/bytes, Rest/binary>>) ->
    {#kt_bin_rec{key = Key, val = Val}, Rest};
read_binrec(
  get_bulk, <<Dbidx:16/big-unsigned-integer, Ksiz:32/big-unsigned-integer,
             Vsiz:32/big-unsigned-integer, Xt:64/big-signed-integer,
             Key:Ksiz/bytes, Val:Vsiz/bytes, Rest/binary>>) ->
    {#kt_bin_rec{key = Key, val = Val, dbidx = Dbidx, xt = Xt}, Rest};
read_binrec(_, _) ->
    undefined.

-spec gen_response(#http_state{}) -> #http_response{}
                ; (#binary_state{}) -> #binary_response{}.
    

gen_response(
  #http_state{status_code = Code, content_length = CL, body = Body, 
              response_enc = Enc}) ->
    #http_response{status_code = Code, response_enc = Enc, 
                   content_length = CL, body = Body};
gen_response(
  #binary_state{type = Type, tot_recs = TR, n_recvd = NR, recs = Recs}) ->
    % might want to lists:reverse(Recs)
    #binary_response{type = Type, tot_recs = TR, n_recvd = NR, recs = Recs}.
    

%% obtain the response encoding method: colenc=_
%% colenc=U -> url encoding
%% colenc=B -> base64 encoding
%% documentation says quoted printable is never used
%%
%% many calls have no need for this value, so this
%% is a little bit of unecessary overhead.
get_colenc(CT) ->
    case string:str(CT, "colenc=") of
        0 -> undefined;
        N ->
            case string:substr(CT, N+7, 1) of
                "U" -> url;
                "B" -> base64;
                CE ->
                    error_logger:error_msg(
                      "Unrecognized colenc=~p in Content-Type: ~p",[CE,CT]),
                    undefined
            end
    end.

                    
